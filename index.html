<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#f0f2f5" />
  <meta name="color-scheme" content="light dark" />
  <title>Голосовой калькулятор</title>
  <link rel="icon" type="image/png" href="img/icon.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <script>
    (function initThemeEarly(){
      const THEME_COLORS={light:'#f0f2f5', dark:'#121212'};
      const themeMeta=document.querySelector('meta[name="theme-color"]');
      const applyThemeColor=theme=>{
        if(!themeMeta) return;
        const color=THEME_COLORS[theme]||THEME_COLORS.light;
        if(themeMeta.getAttribute('content')!==color){
          themeMeta.setAttribute('content', color);
        }
      };
      const KEY='app.theme';
      const FLAG='app.theme.explicit';
      const prefersDark=()=>window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const resolveModeTheme=mode=>mode==='dark' ? 'dark' : mode==='light' ? 'light' : (prefersDark() ? 'dark' : 'light');
      let mode='system';
      try{
        const saved=localStorage.getItem(KEY);
        const explicit=localStorage.getItem(FLAG)==='1';
        if(saved==='system' || !saved){
          mode='system';
        }else if(saved==='dark' || saved==='light'){
          if(explicit){
            mode=saved;
          }else if(saved==='dark'){
            mode='dark';
            localStorage.setItem(FLAG,'1');
          }else{
            mode='system';
            localStorage.removeItem(KEY);
          }
        }
      }catch(err){
        mode='system';
      }
      const theme=resolveModeTheme(mode);
      const docEl=document.documentElement;
      const surface=THEME_COLORS[theme]||THEME_COLORS.light;
      docEl.setAttribute('data-theme', theme);
      docEl.setAttribute('data-theme-mode', mode);
      docEl.style.backgroundColor=surface;
      docEl.style.colorScheme=theme==='dark'?'dark':'light';
      applyThemeColor(theme);
    })();
  </script>
  <style>
    :root{ --bg:#f0f2f5; --fg:#111; --muted:#666; --primary:#0a84ff; --card:#fff; --divider: rgba(0,0,0,.08); --input-bg:#fff;
      --safe-top: env(safe-area-inset-top); --safe-left: env(safe-area-inset-left); --safe-right: env(safe-area-inset-right); --safe-bottom: env(safe-area-inset-bottom); }
    [data-theme="dark"]{ --bg:#121212; --fg:#f5f5f7; --muted:#a0a0a0; --primary:#0a84ff; --card:#1e1e1e; --divider: rgba(255,255,255,0.1); --input-bg:#1b1f24; }
    *{ box-sizing:border-box; }
    html{ background:var(--bg); }
    html[data-theme="dark"]{ color-scheme:dark; }
    html[data-theme="light"]{ color-scheme:light; }
    html,body{ height:100vh; min-height:100vh; overflow:hidden; overscroll-behavior:none; touch-action:pan-x pan-y; }
    @supports (height: 100dvh){ html,body{ height:100dvh; min-height:100dvh; } }
    body{ margin:0; background:var(--bg); color:var(--fg); font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; -webkit-user-select:none; user-select:none; }
    input, textarea{ -webkit-user-select:text; user-select:text; }

    button, select { -webkit-tap-highlight-color: transparent; }
    .btn:focus, .navbtn:focus, .hamb:focus, select:focus { outline: none; }

    .screen{ position:relative; background:var(--card); height:100%; width:100%; overflow:hidden;
      padding: calc(var(--safe-top) + 16px) calc(var(--safe-right) + 16px) calc(var(--safe-bottom) + 20px) calc(var(--safe-left) + 16px);
      display:flex; align-items:stretch; justify-content:center; }
    .wrap{ width:min(640px, 96vw); height:100%; overflow:hidden; display:flex; flex-direction:column; gap:0; padding-top:0; }
    .view{ display:none; flex-direction:column; min-height:calc(100dvh - 64px - var(--safe-top) - var(--safe-bottom)); }
    .view.active{ display:flex; }

    .header{ text-align:center; padding: 0 16px; position:relative; }
    h1{ margin:0 0 8px; font-size:28px; font-weight:800; }
    #status{ color:var(--muted); min-height:24px; margin:0 0 12px; display:flex; align-items:center; justify-content:center; text-align:center; }

    /* Строка выражения — при переполнении уезжает влево, можно скроллить */
    #expr{ font-size:32px; font-weight:600; min-height:36px; margin:4px 0; white-space:nowrap; overflow-x:auto; overflow-y:hidden; text-align:right; -webkit-overflow-scrolling:touch; }
    #expr::-webkit-scrollbar{ display:none; }

    /* Большая строка результата — справа, плавно масштабируется, при переполнении «уезжает» влево */
    #full{ font-weight:800; font-size:64px; color:var(--primary); min-height:56px; margin:8px 0 18px; white-space:nowrap; overflow:hidden; line-height:1.1; text-align:right; will-change:font-size,transform; transition: font-size .18s ease, transform .18s ease; }
    #full[data-overflow="1"]{ -webkit-mask-image: linear-gradient(to right, rgba(0,0,0,0) 0, rgba(0,0,0,.12) 16px, #000 44px); mask-image: linear-gradient(to right, rgba(0,0,0,0) 0, rgba(0,0,0,.12) 16px, #000 44px); }

    .center{ display:flex; justify-content:center; align-items:center; width:100%; margin-top:6px; }
    .btn{ display:grid; place-items:center; border:0; cursor:pointer; user-select:none; touch-action:manipulation; background:var(--primary); color:#fff; box-shadow:0 8px 20px rgba(10,132,255,0.28); transition: transform .08s ease; }
    .btn:active{ transform: scale(.98); }
    .btn.circle{ width:160px; height:160px; border-radius:9999px; }
    .btn .title{ font-weight:800; font-size:16px; letter-spacing:.4px; }

    .history-block{ background:var(--card); border-radius:16px; padding:20px 20px 16px; width:min(360px,calc(100% - 32px)); margin:12px auto calc(36px + var(--safe-bottom)); display:flex; flex-direction:column; gap:16px; max-height:clamp(300px,48vh,440px); overflow:hidden; box-shadow:0 18px 40px rgba(0,0,0,0.28); }
    [data-theme="light"] .history-block{ box-shadow:0 22px 44px rgba(15,24,44,0.12); }
    .history-title{ margin:0; font-size:18px; font-weight:600; text-align:center; color:var(--fg); }
    .history-list{ list-style:none; margin:0; padding:4px 2px 4px 0; flex:1; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y; }
    .history-list::-webkit-scrollbar{ display:none; }
    .history-list li{ padding:14px 0; border-bottom:1px solid var(--divider); display:flex; flex-direction:column; gap:4px; }
    .history-list li:last-child{ border-bottom:0; }
    .history-list .expr{ font-size:16px; font-weight:600; color:var(--fg); line-height:1.35; }
    .history-list .time{ font-size:14px; color:var(--muted); }
    [data-theme="light"] .history-title,
    [data-theme="light"] .history-list .expr,
    [data-theme="light"] .history-list .time{ color:#000; }
    [data-theme="light"] .history-list .time{ color:#5c5c5c; }
    .history-list li.empty{ color:var(--muted); font-size:14px; text-align:center; padding:24px 0; }
    .history-clear{ width:100%; background:#0a84ff; color:#fff; border:0; border-radius:10px; padding:14px 0; font-size:16px; font-weight:600; cursor:pointer; flex-shrink:0; box-shadow:0 10px 24px rgba(10,132,255,0.35); transition:transform .08s ease; }
    .history-clear:active{ transform:scale(.98); }

    .hamb{ position:fixed; top:calc(var(--safe-top) + 10px); left:calc(var(--safe-left) + 14px); width:48px; height:48px; border:0; border-radius:14px; background:var(--primary); color:#fff; font-size:24px; font-weight:800; display:grid; place-items:center; box-shadow:0 6px 16px rgba(10,132,255,.35); cursor:pointer; z-index:1100; }

    .drawer{ position: fixed; inset: 0 auto 0 0; width: min(300px, 90vw); background: var(--card); color: var(--fg); box-shadow: 0 10px 30px rgba(0,0,0,.2); transform: translateX(-100%); transition: none; will-change: transform; z-index: 1001; padding: 136px 18px 18px; overflow: auto; touch-action: none; }
    .scrim{ position: fixed; inset: 0; background: rgba(0,0,0,.6); opacity: 0; pointer-events: none; transition: none; will-change: opacity; z-index: 1000; touch-action: none; }
    #edge{ position:fixed; inset:0 auto 0 0; width:24px; z-index:1002; touch-action:none; background:transparent; }

    .navbtn{ appearance:none; display:block; width:100%; background:var(--input-bg); color:var(--fg); border:1px solid var(--divider); border-radius:18px; padding:16px 20px; margin:14px 0 0; text-align:left; font-weight:700; font-size:18px; box-shadow:0 6px 18px rgba(0,0,0,0.12); cursor:pointer; user-select:none; transition:background-color .15s ease, color .15s ease, box-shadow .15s ease, border-color .15s ease; }
    [data-theme="dark"] .navbtn{ box-shadow:0 10px 24px rgba(0,0,0,0.32); }
    .navbtn:active{ transform:translateY(1px); }
    .navbtn.active{ background:var(--primary); color:#fff; border-color:var(--primary); box-shadow:0 10px 24px rgba(10,132,255,0.32); }

    .about-body{ flex:1; display:flex; flex-direction:column; gap:16px; padding:0 16px; }
    .about-footer{ text-align:center; color:var(--muted); padding-top:6px; margin-bottom:calc(6px + var(--safe-bottom)); }
    .policy{ margin:0; max-height:60vh; overflow:auto; padding:12px; border:1px solid var(--divider); border-radius:12px; }
    .policy h2{ margin:0 0 8px; font-size:20px; font-weight:800; }
    .policy h3{ margin:12px 0 6px; font-size:16px; font-weight:800; }
    .policy p, .policy li { line-height: 1.45; }

    .field{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .label{ color:var(--muted); font-weight:600; }
    .theme-toggle{ display:inline-flex; background:var(--input-bg); border:1px solid var(--divider); padding:4px; border-radius:14px; box-shadow: inset 0 2px 6px rgba(0,0,0,.06); }
    .theme-toggle button{ appearance:none; border:0; background:transparent; padding:8px 12px; border-radius:10px; font-weight:700; color:var(--fg); cursor:pointer; transition:transform .08s ease; }
    .theme-toggle button.active{ background:var(--primary); color:#fff; box-shadow:0 6px 16px rgba(0,0,0,.25); }

    .dots span{ display:inline-block; width:8px; height:8px; background:var(--primary); border-radius:50%; margin:0 3px; animation:b 1.4s infinite ease-in-out both; }
    .dots span:nth-child(1){ animation-delay:-.32s } .dots span:nth-child(2){ animation-delay:-.16s }
    @keyframes b{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
  </style>
</head>
<body>
  <div id="edge"></div>
  <button id="btnMenu" class="hamb" aria-label="Меню">≡</button>

  <aside id="drawer" class="drawer" aria-hidden="true">
    <div style="font-weight:800; font-size:24px; margin-bottom:8px;">Меню</div>
    <button class="navbtn" data-view="calc">Калькулятор</button>
    <button class="navbtn" data-view="settings">Настройки</button>
    <button class="navbtn" data-view="about">О приложении</button>
  </aside>
  <div id="scrim" class="scrim"></div>

  <main class="screen">
    <div class="wrap">
      <section id="view-calc" class="view active">
        <div class="header">
          <h1>Голосовой калькулятор</h1>
          <p id="status"></p>
        </div>
        <div id="expr"></div>
        <div id="full"></div>
        <div class="center">
          <button id="btnListen" class="btn circle"><span class="title" id="btnTitle">НАЖМИ</span></button>
        </div>
        <div style="height:12px"></div>
        <div class="history-block">
          <h2 class="history-title">История вычислений</h2>
          <ul id="historyList" class="history-list"></ul>
          <button id="btnClearHistory" class="history-clear">Очистить</button>
        </div>
      </section>

      <section id="view-settings" class="view">
        <div class="header"><h1>Настройки</h1></div>
        <div class="about-body">
          <div class="field">
            <span class="label">Тема</span>
            <div id="themeToggle" class="theme-toggle" role="group" aria-label="Тема">
              <button type="button" data-value="light">Светлая</button>
              <button type="button" data-value="dark">Тёмная</button>
            </div>
          </div>
        </div>
      </section>

      <section id="view-about" class="view">
        <div class="header"><h1>О приложении</h1></div>
        <div class="about-body">
          <article class="policy">
            <h2>Политика конфиденциальности приложения «Голосовой калькулятор»</h2>
            <p><b>Дата последнего обновления:</b> 5 октября 2025 г.</p>
            <h3>1. Общие положения</h3>
            <p>Мобильное приложение «Голосовой калькулятор» предназначено для голосовых вычислений. Используя Приложение, пользователь соглашается с условиями настоящей Политики.</p>
            <h3>2. Сбор и использование данных</h3>
            <ul>
              <li>Приложение не собирает и не хранит персональные данные пользователей.</li>
              <li>Голосовые команды обрабатываются локально на устройстве исключительно для выполнения вычислений и не передаются на сторонние серверы.</li>
            </ul>
            <h3>3. Разрешения и доступы</h3>
            <p>Приложение запрашивает доступ к микрофону для распознавания голосовых команд.</p>
            <h3>4. Передача третьим лицам</h3>
            <p>Персональные данные не продаются и не передаются третьим лицам. В приложении нет аналитики и рекламы.</p>
            <h3>5. Хранение и защита данных</h3>
            <p>История вычислений хранится локально и может быть удалена пользователем. Серверной части нет.</p>
            <h3>6. Права пользователя</h3>
            <ul>
              <li>отключить доступ к микрофону в системных настройках;</li>
              <li>очистить историю вычислений;</li>
              <li>удалить Приложение.</li>
            </ul>
            <h3>7. Дети</h3>
            <p>Приложение предназначено для широкой аудитории и не собирает данные детей.</p>
            <h3>8. Изменения политики</h3>
            <p>Дата последней редакции указывается в актуальной версии.</p>
            <h3>9. Контакты</h3>
            <p>Почта разработчика: <b>gameloft235@gmail.com</b>.</p>
          </article>
          <div class="about-footer">Версия <b>1.0.8</b></div>
        </div>
      </section>
    </div>
  </main>

  <script src="cordova.js"></script>
  <script>
  (function(){
    const $  = s=>document.querySelector(s);
    const $$ = s=>Array.from(document.querySelectorAll(s));

    /* ===== Блокируем масштабирование жестами ===== */
    (function preventPinchZoom(){
      const stop = e => e.preventDefault();
      document.addEventListener('gesturestart', stop, {passive:false});
      document.addEventListener('gesturechange', stop, {passive:false});
      document.addEventListener('gestureend', stop, {passive:false});
      document.addEventListener('touchstart', e=>{ if(e.touches.length>1) e.preventDefault(); }, {passive:false});
      document.addEventListener('touchmove', e=>{ if(e.touches.length>1) e.preventDefault(); }, {passive:false});
      window.addEventListener('wheel', e=>{ if(e.ctrlKey) e.preventDefault(); }, {passive:false});
    })();

    /* ===== Тема ===== */
    const THEME_KEY='app.theme';
    const THEME_EXPLICIT_KEY='app.theme.explicit';
    const themeToggle=$('#themeToggle');
    const themeMeta=document.querySelector('meta[name="theme-color"]');
    const docEl=document.documentElement;
    const bodyEl=document.body||document.documentElement;
    const SYSTEM_SURFACES={
      light:{ fallback:'#f0f2f5', statusStyle:'dark', navTheme:'light' },
      dark:{ fallback:'#121212', statusStyle:'light', navTheme:'dark' }
    };
    let deviceReady=false;

    const clamp255=v=>Math.max(0,Math.min(255,Math.round(v)));
    function normalizeHex(color){
      if(!color) return null;
      let c=String(color).trim();
      if(/^#[0-9a-f]{3}$/i.test(c)){
        c='#'+c.slice(1).split('').map(ch=>ch+ch).join('');
      }else if(/^#[0-9a-f]{8}$/i.test(c)){
        c='#'+c.slice(-6);
      }else if(!/^#[0-9a-f]{6}$/i.test(c)){
        const m=c.match(/^rgba?\(([^)]+)\)$/i);
        if(m){
          const parts=m[1].split(',').map(p=>parseFloat(p));
          if(parts.length>=3 && parts.slice(0,3).every(n=>Number.isFinite(n))){
            const [r,g,b]=parts;
            c='#'+[clamp255(r),clamp255(g),clamp255(b)].map(v=>v.toString(16).padStart(2,'0')).join('');
          }else{
            return null;
          }
        }else{
          return null;
        }
      }
      return c.toLowerCase();
    }

    function readCSSColor(varName, fallback){
      try{
        const styles=getComputedStyle(docEl);
        if(!styles) return fallback;
        const value=styles.getPropertyValue(varName);
        return value ? value.trim() || fallback : fallback;
      }catch(_){
        return fallback;
      }
    }

    function applyColorScheme(theme){
      const scheme=theme==='dark'?'dark':'light';
      docEl.style.colorScheme=scheme;
      bodyEl.style.colorScheme=scheme;
    }

    function applySystemSurfaces(theme){
      const preset=SYSTEM_SURFACES[theme]||SYSTEM_SURFACES.light;
      const bgColor=readCSSColor('--bg', preset.fallback);
      const metaColor=bgColor||preset.fallback;
      if(themeMeta && metaColor && themeMeta.getAttribute('content')!==metaColor){
        themeMeta.setAttribute('content', metaColor);
      }
      if(metaColor){
        docEl.style.backgroundColor=metaColor;
        bodyEl.style.backgroundColor=metaColor;
      }
      applyColorScheme(theme);
      if(!deviceReady) return;
      const statusHex=normalizeHex(readCSSColor('--bg', preset.fallback))||normalizeHex(metaColor)||normalizeHex(preset.fallback);
      try{
        if(window.StatusBar){
          if(statusHex && typeof StatusBar.backgroundColorByHexString==='function'){
            StatusBar.backgroundColorByHexString(statusHex);
          }
          if(preset.statusStyle==='light'){
            if(typeof StatusBar.styleLightContent==='function') StatusBar.styleLightContent();
          }else if(typeof StatusBar.styleDefault==='function'){
            StatusBar.styleDefault();
          }
        }
      }catch(_){ /* ignore */ }
      try{
        if(window.NavigationBar){
          const navHex=normalizeHex(readCSSColor('--bg', preset.fallback))||statusHex;
          const wantsLightBackground=preset.navTheme==='light';
          if(navHex){
            if(typeof NavigationBar.backgroundColorByHexString==='function'){
              if(NavigationBar.backgroundColorByHexString.length>=2){
                NavigationBar.backgroundColorByHexString(navHex, wantsLightBackground);
              }else{
                NavigationBar.backgroundColorByHexString(navHex);
              }
            }
            if(typeof NavigationBar.setNavigationBarColor==='function'){
              NavigationBar.setNavigationBarColor(navHex.replace('#',''), wantsLightBackground);
            }
          }
          if(typeof NavigationBar.setNavigationBarMode==='function'){
            NavigationBar.setNavigationBarMode(wantsLightBackground ? 'light' : 'dark');
          }
        }
      }catch(_){ /* ignore */ }
    }
    const mediaDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
    let themeMode=document.documentElement.getAttribute('data-theme-mode')||'system';

    function resolveTheme(mode){
      if(mode==='dark' || mode==='light') return mode;
      return mediaDark && mediaDark.matches ? 'dark' : 'light';
    }
    function applyTheme(mode){
      themeMode=mode;
      const theme=resolveTheme(mode);
      docEl.setAttribute('data-theme-mode', mode);
      docEl.setAttribute('data-theme', theme);
      applySystemSurfaces(theme);
    }
    function setThemeUI(mode){
      if(!themeToggle) return;
      const effective = mode==='system' ? resolveTheme('system') : mode;
      themeToggle.querySelectorAll('button').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.value===effective);
      });
    }
    function getStoredTheme(){
      try{ return localStorage.getItem(THEME_KEY); }
      catch(_){ return null; }
    }
    function isThemeExplicit(){
      try{ return localStorage.getItem(THEME_EXPLICIT_KEY)==='1'; }
      catch(_){ return false; }
    }
    function saveTheme(mode){
      try{
        if(mode==='system'){
          localStorage.setItem(THEME_KEY,'system');
          localStorage.removeItem(THEME_EXPLICIT_KEY);
        }else{
          localStorage.setItem(THEME_KEY,mode);
          localStorage.setItem(THEME_EXPLICIT_KEY,'1');
        }
      }catch(_){ /* ignore */ }
    }
    function clearThemePreference(){
      try{
        localStorage.removeItem(THEME_KEY);
        localStorage.removeItem(THEME_EXPLICIT_KEY);
      }catch(_){ /* ignore */ }
    }
    function determineInitialMode(){
      const saved=getStoredTheme();
      const explicit=isThemeExplicit();
      if(saved==='system' || !saved) return 'system';
      if(saved==='dark' || saved==='light'){
        if(explicit){
          return saved;
        }
        if(saved==='dark'){
          saveTheme('dark');
          return 'dark';
        }
        clearThemePreference();
        return 'system';
      }
      return 'system';
    }
    (function initTheme(){
      themeMode = document.documentElement.getAttribute('data-theme-mode') || determineInitialMode();
      applyTheme(themeMode);
      setThemeUI(themeMode);
      if(mediaDark){
        const handleSystemChange=e=>{
          if(themeMode==='system'){
            applyTheme('system');
            setThemeUI('system');
          }
        };
        if(mediaDark.addEventListener) mediaDark.addEventListener('change', handleSystemChange);
        else if(mediaDark.addListener) mediaDark.addListener(handleSystemChange);
      }
      if(themeToggle){
        themeToggle.addEventListener('click', e=>{
          const btn=e.target.closest('button[data-value]');
          if(!btn) return;
          const mode=btn.dataset.value;
          if(mode!=='light' && mode!=='dark') return;
          if(themeMode===mode) return;
          saveTheme(mode);
          applyTheme(mode);
          setThemeUI(mode);
        });
      }
    })();

    document.addEventListener('deviceready', ()=>{
      deviceReady=true;
      try{
        if(window.StatusBar && typeof StatusBar.overlaysWebView==='function'){
          StatusBar.overlaysWebView(false);
        }
      }catch(_){ /* ignore */ }
      applySystemSurfaces(resolveTheme(themeMode));
    });

    /* ===== Шторка (жесты) ===== */
    const drawer=$('#drawer'), scrim=$('#scrim'), btnMenu=$('#btnMenu'), edge=$('#edge');
    let isOpen=false, dragging=false, modeDrag='', startX=0, lastX=0, lastT=0, vX=0, w=0, pos=-300, moved=false;
    const measure=()=>{ w=drawer.getBoundingClientRect().width||280; };
    const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
    const setPos=px=>{ pos=clamp(px,-w,0); drawer.style.transform=`translateX(${pos}px)`; const k=1+pos/w; scrim.style.opacity=(0.6*k).toFixed(3); scrim.style.pointerEvents=k>0.02?'auto':'none'; };
    const stopTr=()=>{ drawer.style.transition='none'; scrim.style.transition='none'; };
    const animateTo=px=>{ drawer.style.transition='transform 280ms cubic-bezier(.2,.8,.2,1)'; scrim.style.transition='opacity 280ms cubic-bezier(.2,.8,.2,1)'; requestAnimationFrame(()=>setPos(px)); setTimeout(stopTr,300); };
    const openDrawer = ()=>{ measure(); isOpen=true; edge.style.pointerEvents='none';  animateTo(0); };
    const closeDrawer= ()=>{ measure(); isOpen=false; edge.style.pointerEvents='auto'; animateTo(-w); };
    const toggleDrawer=()=> isOpen?closeDrawer():openDrawer();
    btnMenu.addEventListener('click',e=>{ e.preventDefault(); toggleDrawer(); });
    scrim.addEventListener('click', closeDrawer);
    let swallowTimer=0;
    let swallowCleanup=null;
    function swallowClick(allowSelector){
      if(swallowCleanup){ swallowCleanup(); }
      const handler=e=>{
        if(allowSelector && e.target.closest(allowSelector)){
          cleanup();
          return;
        }
        e.stopPropagation();
        e.preventDefault();
        cleanup();
      };
      const cleanup=()=>{
        window.removeEventListener('click',handler,true);
        if(swallowTimer){ clearTimeout(swallowTimer); swallowTimer=0; }
        swallowCleanup=null;
      };
      swallowCleanup=cleanup;
      window.addEventListener('click',handler,true);
      swallowTimer=setTimeout(cleanup,300);
    }
    function beginOpen(x){ measure(); dragging=true; modeDrag='open';  startX=lastX=x; lastT=performance.now(); vX=0; moved=false; stopTr(); setPos(-w); }
    function beginClose(x){ measure(); dragging=true; modeDrag='close'; startX=lastX=x; lastT=performance.now(); vX=0; moved=false; stopTr(); setPos(0); }
    function moveTo(x){ const dx=x-startX; if(!moved && Math.abs(dx)>6) moved=true; if(modeDrag==='open') setPos(-w+dx); else setPos(0+dx); const now=performance.now(), dt=now-lastT; if(dt>0){ vX=(x-lastX)/dt; lastX=x; lastT=now; } }
    function endDrag(e){
      if(!dragging) return;
      const allowSelector = modeDrag==='open' ? '.navbtn' : null;
      if(moved) swallowClick(allowSelector);
      e.currentTarget.releasePointerCapture?.(e.pointerId);
      dragging=false;
      const opened=1+pos/w;
      const TH=0.35, VE=0.35;
      if(modeDrag==='open'){
        (opened>TH || vX>VE)?openDrawer():closeDrawer();
      } else {
        (opened<(1-TH) || vX<-VE)?closeDrawer():openDrawer();
      }
    }
    edge.addEventListener('pointerdown',e=>{ edge.setPointerCapture(e.pointerId); beginOpen(e.clientX); });
    edge.addEventListener('pointermove', e=>{ if(dragging&&modeDrag==='open')  moveTo(e.clientX); });
    edge.addEventListener('pointerup',   endDrag); edge.addEventListener('pointercancel',endDrag);
    drawer.addEventListener('pointerdown',e=>{
      if(e.target.closest('.navbtn')) return; // allow immediate taps on menu buttons
      drawer.setPointerCapture?.(e.pointerId);
      beginClose(e.clientX);
    });
    drawer.addEventListener('pointermove', e=>{ if(dragging&&modeDrag==='close') moveTo(e.clientX); });
    drawer.addEventListener('pointerup',   endDrag); drawer.addEventListener('pointercancel',endDrag);
    scrim.addEventListener('pointerdown', e=>{ scrim.setPointerCapture?.(e.pointerId); beginClose(e.clientX); });
    scrim.addEventListener('pointermove', e=>{ if(dragging&&modeDrag==='close') moveTo(e.clientX); });
    scrim.addEventListener('pointerup',   endDrag); scrim.addEventListener('pointercancel',endDrag);

    /* ===== Навигация ===== */
    const views={calc:'#view-calc',settings:'#view-settings',about:'#view-about'};
    const setActiveNav=view=>{
      $$('.navbtn').forEach(btn=>btn.classList.toggle('active', btn.dataset.view===view));
    };
    const showView=k=>{
      Object.values(views).forEach(sel=>document.querySelector(sel).classList.remove('active'));
      (document.querySelector(views[k])||document.querySelector(views.calc)).classList.add('active');
      setActiveNav(k in views ? k : 'calc');
    };
    const activateNav=view=>{ showView(view); closeDrawer(); };
    $$('.navbtn').forEach(btn=>{
      let pointerActive=false;
      let suppressClick=false;
      const view=btn.dataset.view;
      btn.addEventListener('pointerdown',e=>{
        if(e.pointerType==='mouse' && e.button!==0) return;
        pointerActive=true;
        if(typeof swallowCleanup==='function') swallowCleanup();
      });
      const resetPointer=()=>{ pointerActive=false; };
      btn.addEventListener('pointerleave', resetPointer);
      btn.addEventListener('pointercancel', resetPointer);
      btn.addEventListener('pointerup',e=>{
        if(!pointerActive) return;
        if(e.pointerType==='mouse' && e.button!==0) return;
        pointerActive=false;
        suppressClick=true;
        e.preventDefault();
        activateNav(view);
        setTimeout(()=>{ suppressClick=false; },0);
      });
      btn.addEventListener('click',e=>{
        if(suppressClick) return;
        activateNav(view);
      });
    });
    setActiveNav('calc');

    /* ===== История ===== */
    const HIST_KEY='calc.history', historyList=$('#historyList');
    const loadHistory=()=>{try{return JSON.parse(localStorage.getItem(HIST_KEY)||'[]')}catch(_){return[]}};
    const saveHistory=a=>localStorage.setItem(HIST_KEY,JSON.stringify(a));
    const pushHistory=(expr,res)=>{ const a=loadHistory(); a.unshift({t:Date.now(),expr,res}); if(a.length>200)a.length=200; saveHistory(a); renderHistory(); };
    const formatTime=ts=>new Date(ts).toLocaleString();
    function renderHistory(){
      const a=loadHistory();
      historyList.innerHTML = a.length
        ? a.map(i=>`<li><div class="expr">${i.expr} = ${i.res}</div><div class="time">${formatTime(i.t)}</div></li>`).join('')
        : '<li class="empty">Пока пусто</li>';
    }
    $('#btnClearHistory').addEventListener('click',()=>{ saveHistory([]); renderHistory(); });

    /* ===== Форматирование и вычисление ===== */
    function formatNumberSpaces(num){
      if (num == null || !isFinite(num)) return '';
      const s = String(num);
      const [intPart, fracPart] = s.split('.');
      const intFmt = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
      return fracPart ? `${intFmt}.${fracPart}` : intFmt;
    }

    const calc = s => {
        // Basic validation to prevent eval-ing unwanted code
        if (/[^0-9+\-*/.()\s]/.test(s)) {
            throw new Error("Invalid characters in expression");
        }
        const v = Function('"use strict";return(' + s + ')')();
        if (!isFinite(v) || isNaN(v)) throw new Error("Invalid result");
        return parseFloat(Number(v).toFixed(4)).toString();
    };

    /* ===== UI helpers ===== */
    const UI={ status:$('#status'), expr:$('#expr'), full:$('#full'), btnTitle:$('#btnTitle'),
      setListening(on){ this.status.innerHTML = on? '<div class="dots"><span></span><span></span><span></span></div>' : ''; if(this.btnTitle) this.btnTitle.textContent = on? 'ГОВОРИ' : 'НАЖМИ'; },
      msg(m){ if(this.status) this.status.textContent=m; }
    };

    function fitFullText(text){
      const el = UI.full; if(!el) return;
      if (typeof text === 'string') el.textContent = text;
      if (!fitFullText._raf) fitFullText._raf = 0; cancelAnimationFrame(fitFullText._raf);
      fitFullText._raf = requestAnimationFrame(()=>{
        const parent = el.parentElement || el;
        const pad = 0.98;
        const MAX = 72, MIN = 18;
        const len = el.textContent.length || 1;
        const rough = Math.min(MAX, Math.max(MIN, Math.floor((parent.clientWidth * pad) / Math.max(8, len))));
        el.style.fontSize = rough + 'px';
        let low = MIN, high = MAX, best = rough;
        for (let i=0;i<12;i++){
          const mid = Math.round((low+high)/2);
          el.style.fontSize = mid + 'px';
          if (el.scrollWidth <= parent.clientWidth * pad){ best = mid; low = mid + 1; } else { high = mid - 1; }
        }
        el.style.fontSize = best + 'px';
        const overflow = el.scrollWidth > parent.clientWidth;
        el.dataset.overflow = overflow ? '1' : '0';
        el.style.textAlign = 'right';
      });
    }

    let calculationTimer = null;
    let lastExpr = '';
    let lastResult = '';

    function toUiExpr(input) {
      let s = String(input || '');
      s = s.toLowerCase();

      // --- вспомогательные «границы слова» для Юникода ---
      const WB = '(^|[^\\p{L}\\p{N}])';
      const WE = '(?=$|[^\\p{L}\\p{N}])';
      function rx(word){ return new RegExp(`${WB}${word}${WE}`, 'giu'); }

      // 1) мини-словарь 1–9 (как отдельные слова)
      s = s.replace(rx('(один|одна|одно)'), '$11');
      s = s.replace(rx('(два|две)'),        '$12');
      s = s.replace(rx('три'),              '$13');
      s = s.replace(rx('четыре'),           '$14');
      s = s.replace(rx('пять'),             '$15');
      s = s.replace(rx('шесть'),            '$16');
      s = s.replace(rx('семь'),             '$17');
      s = s.replace(rx('восемь'),           '$18');
      s = s.replace(rx('девять'),           '$19');

      // 2) русские операторы словами -> символы
      s = s.replace(rx('плюс'),   '$1+')
           .replace(rx('минус'),  '$1-')
           .replace(rx('(умножить|умножь|помножить|помножь)(\\s*на)?'), '$1*')
           .replace(rx('(разделить|поделить|делить)(\\s*на)?'),         '$1/');

      // 2.1) отдельный кейс: "2 на 3", "(1+2) на 4" -> умножение
      s = s.replace(/(\d|\))\s*на\s*(?=\d|\()/giu, '$1*');
      
      // 3) проценты (слова)
      s = s.replace(/(\d+)\s*процент(?:а|ов)?\b/gi, '$1%');

      return s.trim();
    }

    function normalizeExpr(input) {
      let s = String(input || '');

      // 1) унификация пробелов/операторов
      s = s.replace(/[\u00A0\u202F\u2007\u2060]/g, ' ')
           .replace(/[×xXхХ⋅∙·]/g, '*')
           .replace(/[÷:]/g, '/')
           .replace(/[−–—]/g, '-')
           .toLowerCase();

      // --- вспомогательные «границы слова» для Юникода ---
      const WB = '(^|[^\\p{L}\\p{N}])';      // слева не буква/цифра или начало
      const WE = '(?=$|[^\\p{L}\\p{N}])';    // справа конец или не буква/цифра

      function rx(word){ return new RegExp(`${WB}${word}${WE}`, 'giu'); } // с флагом 'u'!

      // 1) мини-словарь 1–9 (как отдельные слова)
      s = s.replace(rx('(один|одна|одно)'), '$11');
      s = s.replace(rx('(два|две)'),        '$12');
      s = s.replace(rx('три'),              '$13');
      s = s.replace(rx('четыре'),           '$14');
      s = s.replace(rx('пять'),             '$15');
      s = s.replace(rx('шесть'),            '$16');
      s = s.replace(rx('семь'),             '$17');
      s = s.replace(rx('восемь'),           '$18');
      s = s.replace(rx('девять'),           '$19');

      // 2) русские операторы словами -> символы
      s = s.replace(rx('плюс'),   '$1+')
           .replace(rx('минус'),  '$1-')
           .replace(rx('(умножить|умножь|помножить|помножь)(\\s*на)?'), '$1*')
           .replace(rx('(разделить|поделить|делить)(\\s*на)?'),         '$1/');

      // 2.1) отдельный кейс: "2 на 3", "(1+2) на 4" -> умножение
      s = s.replace(/(\d|\))\s*на\s*(?=\d|\()/giu, '$1*');

      // 3) масштабы: млрд/млн/тыс -> арифметика
      s = s.replace(/\b(\d+)\s*(млрд|миллиард[а-я]*)\b/gi, '($1*1000000000)');
      s = s.replace(/\b(\d+)\s*(млн|миллион[а-я]*)\b/gi,   '($1*1000000)');
      s = s.replace(/\b(\d+)\s*(тыс|тысяч[а-я]*)\b/gi,     '($1*1000)');

      // если несколько масштабов подряд — вставить '+'
      s = s.replace(/\)\s+(?=\()/g, ')+(');   // ") (" -> ")+("
      s = s.replace(/(\))\s+(\d)/g, '$1+$2'); // ") 500" -> ")+500"
      s = s.replace(/(\d)\s+(\()/g, '$1+(');  // "500 (" -> "500+("

      // 1.234.567,89 / 1.234.567.89 (точка дробная, если единственная и 1–2 знака)
      // 1.300.000 -> 1300000  (хвост .000 — это тысячная группа)
      // 1.234.567.89 -> 1 234 567  (последняя .89 отбрасывается как невалидная группировка)
      s = s.replace(/\b(\d{1,3}(?:[ \u00A0\u202F.]\d{3})+)([.,](\d+))\b/g,
        (_, intPart, sepFrac, frac) => {
          const intClean     = intPart.replace(/[ \u00A0\u202F.]/g, '');
          const sep          = sepFrac[0];
          const hasOtherDots = intPart.includes('.');

          if (sep === ',') {
            // запятая всегда дробная
            return intClean + '.' + frac;
          }
          if (sep === '.' && !hasOtherDots && frac.length <= 2) {
            // единственная точка и 1–2 знака -> десятичная
            return intClean + '.' + frac;
          }
          if (sep === '.' && hasOtherDots && frac.length === 3) {
            // есть другие точки -> это тысячная группа из 3 цифр (в т.ч. .000)
            return intClean + frac;
          }
          // иначе отбросить «хвост» после точки (напр. .89 в 1.234.567.89)
          return intClean;
      });

      s = s.replace(/\b(\d{1,3}(?:[ \u00A0\u202F.]\d{3})+)\b/g,
        intPart => intPart.replace(/[ \u00A0\u202F.]/g,'')
      );

      // 5) остаточные запятые → точки
      s = s.replace(/,/g, '.');

      // проценты
      s = s.replace(/(\d+)\s*процент(?:а|ов)?\b/gi, '$1%'); // слова -> знак
      s = s.replace(/(\d+)\s*%/g, '($1/100)');              // 10% -> (10/100)
      s = s.replace(/\)\s*на\s*(?=\d|\()/gi, ')*');         // "10% на 500" -> "(10/100) * 500"

      // 7) финальная чистка пробелов
      return s.replace(/\s+/g, ' ').trim();
    }

    function calculateAndShow(expr) {
        if (!expr) {
            fitFullText('');
            return;
        }
        lastExpr = expr;
        try {
            const mathExpr = normalizeExpr(expr);
            // защита: убираем хвост из операторов («10 +» → «10»)
            const safe = mathExpr.replace(/[+\-*/.\s]+$/, '');
            if (!safe) throw new Error('Empty');
            const result = calc(safe);
            const resultFmt = formatNumberSpaces(result);
            fitFullText(resultFmt);
            lastResult = resultFmt;
        } catch (e) {
            fitFullText('');
            lastResult = '';
        }
    }

    function updateLive(phrase) {
      const uiExpr = toUiExpr(phrase);
      if (UI.expr) {
          UI.expr.textContent = uiExpr;
          UI.expr.scrollLeft = UI.expr.scrollWidth;
      }
      fitFullText('');
      lastResult = '';

      if (calculationTimer) {
          clearTimeout(calculationTimer);
      }
      // No more timeout, calculate directly.
      calculateAndShow(phrase);
    }

    function commitResult() {
        if (calculationTimer) {
            clearTimeout(calculationTimer);
            calculationTimer = null;
        }
        const currentExpr = UI.expr.textContent;
        if (currentExpr) {
            if (!lastResult) {
                calculateAndShow(lastExpr);
            }
            if (lastExpr && lastResult) {
                pushHistory(toUiExpr(lastExpr), lastResult);
            }
        }
        lastExpr = '';
        lastResult = '';
    }

    /* ===== Распознавание (Web + Cordova) ===== */
    let sessionActive = false;
    let watchdogTimer = null;
    const recognizer = {
        mode: 'none',
        available: false,
        _rec: null,
        start() { UI.msg('Распознавание речи недоступно. Нужен HTTPS/localhost или плагин Cordova.'); navigator.vibrate && navigator.vibrate(30); },
        stop() { stopSession(); },
    };

    function stopSession() {
        if (!sessionActive) return;
        sessionActive = false;
        if (watchdogTimer) {
            clearTimeout(watchdogTimer);
            watchdogTimer = null;
        }
        UI.setListening(false);
        if (recognizer._rec) {
            if (recognizer.mode === 'web') {
                try { recognizer._rec.abort(); } catch (e) {}
            } else if (recognizer.mode === 'cordova') {
                try { recognizer._rec.stopListening(() => {}, () => {}); } catch (e) {}
            }
        }
        commitResult();
    }

    (function setupWeb() {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        const secure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        if (!SR || !secure) return;

        let rec = null;

        function startSession() {
            if (sessionActive) return;
            sessionActive = true;
            UI.setListening(true);
            fitFullText('');
            if (UI.expr) { UI.expr.textContent = ''; UI.expr.scrollLeft = 0; }

            rec = new SR();
            recognizer._rec = rec;
            rec.lang = 'ru-RU';
            rec.continuous = false;
            rec.interimResults = false;
            rec.maxAlternatives = 1;

            rec.onresult = (e) => {
                if (watchdogTimer) clearTimeout(watchdogTimer);
                const transcript = e.results[0][0].transcript.trim();
                if (transcript) {
                    updateLive(transcript);
                }
                stopSession();
            };

            rec.onspeechend = stopSession;
            rec.onerror = stopSession;
            rec.onend = stopSession;

            try {
                rec.start();
                watchdogTimer = setTimeout(() => {
                    watchdogTimer = null;
                    stopSession();
                }, 7000);
            } catch (e) {
                stopSession();
            }
        }

        recognizer.mode = 'web';
        recognizer.available = true;
        recognizer.start = startSession;
        recognizer.stop = stopSession;

        document.addEventListener('visibilitychange', () => { if (document.hidden && sessionActive) { stopSession(); } });
    })();

    document.addEventListener('deviceready', () => {
        try {
            const rec = window.plugins && window.plugins.speechRecognition;
            if (!rec) return;

            recognizer.mode = 'cordova';
            recognizer.available = true;
            recognizer._rec = rec;

            const startSession = () => {
                if (sessionActive) return;

                const go = () => {
                    sessionActive = true;
                    UI.setListening(true);
                    fitFullText('');
                    if (UI.expr) { UI.expr.textContent = ''; UI.expr.scrollLeft = 0; }

                    const options = { language: 'ru-RU', matches: 1, showPartial: false, showPopup: false };

                    rec.startListening(
                        (matches) => {
                            if (watchdogTimer) clearTimeout(watchdogTimer);
                            const phrase = (matches && matches[0]) ? String(matches[0]).trim() : '';
                            if (phrase) {
                                updateLive(phrase);
                            }
                            stopSession();
                        },
                        (err) => {
                            if (sessionActive) stopSession();
                        },
                        options
                    );

                    watchdogTimer = setTimeout(() => {
                        watchdogTimer = null;
                        stopSession();
                    }, 7000);
                };

                rec.hasPermission(
                    (has) => {
                        if (has) go();
                        else rec.requestPermission(go, () => UI.msg('Нет доступа к микрофону.'));
                    },
                    () => UI.msg('Ошибка проверки разрешений.')
                );
            };

            recognizer.start = startSession;
            recognizer.stop = stopSession;
        } catch (e) {
            console.error("Error setting up Cordova speech recognition:", e);
        }
    }, false);

    $('#btnListen').addEventListener('click', e=>{ e.preventDefault(); if(!recognizer.available){ UI.msg('Нужен HTTPS/localhost (Web) или плагин speechrecognition (Cordova).'); navigator.vibrate && navigator.vibrate(30); return; } if(!sessionActive) recognizer.start(); else recognizer.stop(); });

    try{ const calcView=document.querySelector('#view-calc'); if(window.ResizeObserver&&calcView){ const ro=new ResizeObserver(()=>fitFullText()); ro.observe(calcView); } window.addEventListener('resize', ()=>fitFullText()); window.addEventListener('orientationchange', ()=>fitFullText()); }catch{}

    renderHistory();
  })();
  </script>
</body>
</html>